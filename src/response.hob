import io;
import mem;
import optional;
import list;
import "common.hob" as common;

use list.List;
use optional.Optional;
use common.{ ProtocolVersion, Header };

public type StatusCode = enum {
    continueRequest = 100,
    switchingProtocols,
    processingDeprecated,
    earlyHints,

    ok = 200,
    created,
    accepted,
    nonAuthoritativeInformation,
    noContent,
    resetContent,
    partialContent,
    multiStatus,
    alreadyReported,
    imUsed,

    multipleChoices = 300,
    movedPermanently,
    found,
    seeOther,
    notModified,
    useProxyDeprecated,
    _reserved,
    temporaryRedirect,
    permanentRedirect,

    badRequest = 400,
    unauthorized,
    paymentRequired,
    forbidden,
    notFound,
    methodNotAllowed,
    notAcceptable,
    proxyAuthenticationRequired,
    requestTimeout,
    conflict,
    gone,
    lengthRequired,
    preconditionFailed,
    contentTooLarge,
    uriTooLong,
    unsupportedMediaType,
    rangeNotSatisfiable,
    expectationFailed,
    imATeapot,
    misdirectedRequest,
    unprocessableContent,
    locked,
    failedDependency,
    tooEarlyExperimental,
    upgradeRequired,
    preconditionRequired,
    tooManyRequests,
    requestHeaderFieldsTooLarge,
    unavailableForLegalReasons,

    internalServerError = 500,
    notImplemented,
    badGateway,
    serviceUnavailable,
    gatewayTimeout,
    httpVersionNotSupported,
    variantAlsoNegotiates,
    insufficientStorage,
    loopDetected,
    notExtended,
    networkAuthenticationRequired,
};

public type Body = struct {
    public data: *void,
    public send: fun (io.fd.Fd, *void),
    public free: fun (*void),
};

public fun newBody<T>(data: T, send: fun (io.fd.Fd, *T), free: fun (*T)) -> Body {
    return {
        data: mem.allocateWith.<T>(data),
        send: send,
        free: free,
    };
}

public type Response = struct {
    public protocolVersion: ProtocolVersion,
    public statusCode: StatusCode,
    public headers: List.<Header>,
    public body: Optional.<Body>,
};

public fun Response.free(self) {
    if !self.body.isEmpty {
        self.body.value.free(self.body.value.data);
    }
    self.headers.free();
}
